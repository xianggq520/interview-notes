# any

尽可能不用的类型，不安全。

# unknow

`unknow`类型比`any`类型安全，无法访问`unknow`类型变量的属性，any 可以访问。

```ts
function f1(a: any) {
  a.b()；//yes
}
function f2(a: unknown) {
  a.b(); //error
}

```

# void

当函数没有返回值时，函数的返回值类型就是 void。

# never

永远不会被检测到的值的类型

```ts
// void
function fail(msg: string) {
  throw new Error(msg);
}
// never fail函数永远没有返回值
function fail1(msg: string): never {
  throw new Error(msg);
}

// 联合类型分支缩小无法达到的分支
function fn(x: string | number) {
  if (typeof x === 'string') {
    //做一些事
  } else if (typeof x === 'number') {
    //再做一些事
  } else {
    x; // 'never"!
  }
}
```

# object

`object` 指的是任何的不是基元的值，包括`function`

`string` `number` `bigint` `boolean` `symbol` `null` `undefined`

# Function

全局性的 Function 类型描述了诸如 bind call apply和其他存在于JavaScript中所有函数值的属性。亡还有一个特殊的属性;
即Function 类型的值总是可以被调用；
这些函数调用返回any;

由于`Function`类型函数调用后的返回值始终都是any，因此**推荐使用`() => void`代替`Function`类型**

```ts

/**
 * 全局性的 Function 类型描述了诸如 bind call apply和其他存在于JavaScript中所有函数值的属性。亡还有一个特殊的属性;
 * 即Function 类型的值总是可以被调用；
 * 这些函数调用返回any;
 */
function doSomething(fn: Function) {
  return fn(1, 2, 3);
}
```

# ReturnType<T>


```ts
// ReturnType<T> T须为函数类型，获取T的返回值类型
type Predicate = (x: unknown) => boolean
type K = ReturnType<Predicate>
function f() {
  return {
  X: 10,
  у: 3
}
type P = ReturnType<typeof f> // typeof f 获取f的类型：函数类型  ReturnType<T> 
// const p: P = 100// error

```