{"version":3,"file":"bundle.js","sources":["../src/index.ts"],"sourcesContent":["/**\n * 基本类型\n * \n * number, string, boolean, symbol, BigInt\n */\nconst a:string = '12b'\n\n\n/**\n * undefined, null\n * 任何类型的子类型，\n */\nconst dd:string|null = null // 严格模式会报错\n\n\n// void 函数无返回值\n\nfunction tet(): void {}\n\n// never\nfunction ttt(): never {\n  throw new Error()\n  // while(true) {}\n}\n\nconst nv:string|number|never = 'abc'\n\n/**\n * 引用类型\n */\n\nconst arr:Array<string | number> = [1, 2, 'a']\nconst arr2: (string|number)[] = [1, 2, 'a']\n\nconst str1:String = \"abc\"\nconst str2:String = new String(\"abc\")\n// const str3:string = new String(\"abc\")\n\n// tuple\nconst abc:[string, number, string] = ['abc', 4, \"def\"]\n\n// 枚举类型 enum\n// 常量枚举 const enum\nenum Tool {\n  bans,\n  qianzi\n}\n\nconst tool:Tool = Tool.bans\n\nconsole.log(tool)\n\nconst enum Animal {\n  dog,\n  horse,\n  mouse\n}\n\nconst mj:Animal = Animal.dog\n\nconsole.log(mj)\n\n\n// 断言\n// 非空断言 expr!\n\nconst el = document.getElementById(\"app\")\nel!.style.background = 'red';\n\n// el?.style.display js 可选链读值操作\n// el??\"abc\"  js 控制合并操作符 null和undefined时返回 abc\n\n//  断言 as\n(el as HTMLElement).style.background = 'red';\n(<HTMLElement>el).style.background = 'red'; // 不推荐\n\n\n// this\n\nconst person = {\n  name: \"zs\",\n  age: 43\n}\ntype IThis = typeof person\nfunction getVal(this: IThis, key: keyof IThis) {\n  return this[key]\n}\n\ngetVal.call(person, \"age\")\n\n// 重载\nfunction toArray(value: number): number[];\nfunction toArray(value: string): string[];\nfunction toArray(value: number| string): number[]|string[] {\n  if (typeof value === \"string\") {\n    return value.split(\"\");\n  } else {\n    return value.toString().split(\"\").map(Number)\n  }\n}\n// 缩小联合类型范围\nconst result = toArray('123')\nconst result2 = toArray(123)\n\n\n// class\nclass Person { \n  // static \n  static family: string = \"zs\"\n  static getFamily() {return this.family}\n  // constructor\n  constructor(public name: string, protected age: number, private sex: string, readonly parent: string) {}\n  // getter 、 setter\n  get _sex() { return this.sex}\n  set _sex(val: string) {\n    this.sex = val\n  }\n  // prototype fns\n  print(name: string): void {\n  }\n}\n\nclass Zs extends Person {\n  static getFamily() {return super.getFamily()} // super.getFamily() 调用 Person 类的静态方法\n\n  // override parent fn.  parent fn 的返回值必须是 void 的才能 override 成不同的返回类型\n  print(name: string): string {\n    super.print(\"abc\") // 这里的 super.print 指的是 Person 原型方法\n    return \"abc\"\n  }\n}"],"names":[],"mappings":";;;EAAA;;;;EAIG;EAqCH;EACA;EACA,IAAK,IAGJ;EAHD,CAAA,UAAK,IAAI,EAAA;EACP,IAAA,IAAA,CAAA,IAAA,CAAA,MAAA,CAAA,GAAA,CAAA,CAAA,GAAA,MAAI;EACJ,IAAA,IAAA,CAAA,IAAA,CAAA,QAAA,CAAA,GAAA,CAAA,CAAA,GAAA,QAAM;EACR,CAAC,EAHI,IAAI,KAAJ,IAAI,GAAA,EAAA,CAAA,CAAA;EAKT,MAAM,IAAI,GAAQ,IAAI,CAAC,IAAI;EAE3B,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC;EAEjB,IAAW,MAIV;EAJD,CAAA,UAAW,MAAM,EAAA;EACf,IAAA,MAAA,CAAA,MAAA,CAAA,KAAA,CAAA,GAAA,CAAA,CAAA,GAAA,KAAG;EACH,IAAA,MAAA,CAAA,MAAA,CAAA,OAAA,CAAA,GAAA,CAAA,CAAA,GAAA,OAAK;EACL,IAAA,MAAA,CAAA,MAAA,CAAA,OAAA,CAAA,GAAA,CAAA,CAAA,GAAA,OAAK;EACP,CAAC,EAJU,MAAM,KAAN,MAAM,GAAA,EAAA,CAAA,CAAA;EAMjB,MAAM,EAAE,GAAU,MAAM,CAAC,GAAG;EAE5B,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC;EAGf;EACA;EAEA,MAAM,EAAE,GAAG,QAAQ,CAAC,cAAc,CAAC,KAAK,CAAC;EACzC,EAAG,CAAC,KAAK,CAAC,UAAU,GAAG,KAAK;EAE5B;EACA;EAEA;EACC,EAAkB,CAAC,KAAK,CAAC,UAAU,GAAG,KAAK;EAC9B,EAAG,CAAC,KAAK,CAAC,UAAU,GAAG,KAAK,CAAC;EAG3C;EAEA,MAAM,MAAM,GAAG;EACb,IAAA,IAAI,EAAE,IAAI;EACV,IAAA,GAAG,EAAE;GACN;EAED,SAAS,MAAM,CAAc,GAAgB,EAAA;EAC3C,IAAA,OAAO,IAAI,CAAC,GAAG,CAAC;EAClB;EAEA,MAAM,CAAC,IAAI,CAAC,MAAM,EAAE,KAAK,CAAC;EAK1B,SAAS,OAAO,CAAC,KAAqB,EAAA;EACpC,IAAA,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;EAC7B,QAAA,OAAO,KAAK,CAAC,KAAK,CAAC,EAAE,CAAC;MACxB;WAAO;EACL,QAAA,OAAO,KAAK,CAAC,QAAQ,EAAE,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,MAAM,CAAC;MAC/C;EACF;EACA;EACe,OAAO,CAAC,KAAK;EACZ,OAAO,CAAC,GAAG;;;;;;"}