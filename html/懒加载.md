
# 判断元素在可视区域的常见方法

参考 https://juejin.cn/post/6844903725249609741

1. el.offsetTop - document.documentElement.scrollTop <= viewPortHeight

```js

function isInViewPortOfOne (el) {
    // viewPortHeight 兼容所有浏览器写法
    const viewPortHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight 
    const offsetTop = el.offsetTop
    const scrollTop = document.documentElement.scrollTop
    const top = offsetTop - scrollTop
    console.log('top', top)
     // 这里有个+100是为了提前加载+ 100
    return top <= viewPortHeight + 100
}

```

2. el.getBoundingClientReact().top <= viewPortHeight

el.offsetTop - document.documentElement.scrollTop = el.getBoundingClientRect().top

```js
function isInViewPortOfTwo (el) {
    const viewPortHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight 
    const top = el.getBoundingClientRect() && el.getBoundingClientRect().top
    console.log('top', top)
    return top  <= viewPortHeight + 100
}

```

3. intersectionRatio > 0 && intersectionRatio <= 1

`IntersectionObserver`检测元素和父元素/`viewport`的交互情况

用途：

- 图片懒加载——当图片滚动到可见时才进行加载
- 内容无限滚动——也就是用户滚动到接近内容底部时直接加载更多，而无需用户操作翻页，给用户一种网页可以无限滚动的错觉
- 检测广告的曝光情况——为了计算广告收益，需要知道广告元素的曝光情况
- 在用户看见某个区域时执行任务或播放动画

```js

let options = {
  root: document.querySelector('#scrollArea'), // 如果root元素不可滚动，则自动调整为设备视窗，同root：null
  rootMargin: '0px',
  threshold: 1.0
}

let observer = new IntersectionObserver(callback, options);

```

```js
// 定义一个观察器
// 回调函数会在第一次监听元素、检测到有交集时执行
const io = new IntersectionObserver(ioes => {
    ioes.forEach(ioe => {
        const el = ioe.target
        const intersectionRatio = ioe.intersectionRatio
        if (intersectionRatio > 0 && intersectionRatio <= 1) {
            // loadImg(el) // 图片懒加载用
            io.unobserve(el)
        }
         el.onload = el.onerror = () => io.unobserve(el)
    })
})
// 初始化观察器
function isInViewPortOfThree (el) {
  // 如果el元素不可滚动，则自动调整为设备视窗
  io.observe(el)
}

```

4. requestIdleCallback

window.requestIdleCallback() 方法插入一个函数，这个函数将在浏览器空闲时期被调用

`requestIdleCallback(callback, options) => id`
`options: { timeout }`
`cancelIdleCallback(id)`