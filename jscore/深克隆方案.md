## 1、递归克隆

```js
const isComplexDataType = function (obj) {
  return (typeof obj === 'object' || typeof obj === 'function') && obj !== null;
};
const deepClone = function (obj, hash = new WeakMap()) {
  if (obj.constructor === Date) {
    return new Date(obj); // 日期则直接返回新的日期对象
  }
  if (obj.constructor === RegExp) {
    return new RegExp(obj); //正则对象直接返回一个新的正则对象
  }
  //如果循环引用了就用 weakMap 来解决循环引用
  if (hash.has(obj)) return hash.get(obj);
  // 所有键的descriptor
  let allDesc = Object.getOwnPropertyDescriptors(obj);
  // 继承原型链
  let cloneObj = Object.create(Object.getPrototypeOf(obj), allDesc);
  // 解决循环引用
  hash.set(obj, cloneObj);
  // Reflect.ownKeys便于处理Symbol类型的key, Object.keys则处理不来Symbol类型的key
  for (let key of Reflect.ownKeys(obj)) {
    cloneObj[key] =
      isComplexDataType(obj[key]) && typeof obj[key] !== 'function'
        ? deepClone(obj[key], hash)
        : obj[key];
  }
  return cloneObj;
};

// test

let a = {
  name: 1
};
a.self = a;

let b = deepClone(a);

console.log(a === b, a.self === b.self);
```

## 2、JSON.stringify 和 JSON.parse 深克隆的缺点

    如果obj里面有时间对象，则JSON.stringify后再JSON.parse的结果，时间将只是字符串的形式。而不是时间对象；
    如果obj里有RegExp、Error对象，则序列化的结果将只得到空对象；
    如果obj里有function，Symbol 类型，undefined，则序列化的结果会把函数或 undefined丢失；
    如果obj里有NaN、Infinity和-Infinity，则序列化的结果会变成null 
    JSON.stringify()只能序列化对象的可枚举的自有属性，例如 如果obj中的对象是有构造函数生成的， 则使用JSON.parse(JSON.stringify(obj))深拷贝后，会丢弃对象的constructor；

## 3、MessageChannel

```js
function structuralClone(obj) {
  return new Promise((resolve) => {
    const { port1, port2 } = new MessageChannel();
    port2.onmessage = (ev) => resolve(ev.data);
    port1.postMessage(obj);
  });
}
```

缺点，无法拷贝函数属性
