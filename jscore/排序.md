# 冒泡排序

![冒泡排序](assets/冒泡排序.gif)

**时间复杂度 O(n^2)**

比较相邻的元素。如果第一个比第二个大，就交换他们两个。
对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。

```js
function bubbleSort(arr) {
  var len = arr.length;
  for (var i = 0; i < len - 1; i++) {
    for (var j = 0; j < len - 1 - i; j++) {
      if (arr[j] > arr[j + 1]) {
        // 相邻元素两两对比
        var temp = arr[j + 1]; // 元素交换
        arr[j + 1] = arr[j];
        arr[j] = temp;
      }
    }
  }
  return arr;
}
```

# 快速排序 quickSort

![快速排序](assets/快速排序.gif)

**时间复杂度 O(nlogn)**

快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。

```js
// 方案1
// 不操作原数组

function quickSort(arr) {
  if (arr.length <= 1) return arr;
  arr = arr.slice();
  let pivot = arr.splice(arr.length >> 1, 1)[0];
  let left = [];
  let right = [];
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] < pivot) {
      left.push(arr[i]);
    } else {
      right.push(arr[i]);
    }
  }
  return quickSort(left).concat([pivot], quickSort(right));
}

let arr = Array(10)
  .fill(0)
  .map(() => parseInt(Math.random() * 100));
console.log(arr);
let ret = quickSort(arr);
console.log(ret);

// 方案2
// 直接操作原数组
function quickSort2(arr, left, right) {
  if (!(Array.isArray(arr) || arr.length > 0)) return arr;
  let len = arr.length,
    pivotIndex;
  if (typeof left !== 'number') {
    left = 0;
  }
  if (typeof right !== 'number') {
    right = len - 1;
  }
  if (left < right) {
    pivotIndex = partition(arr, left, right);
    quickSort2(arr, left, pivotIndex - 1);
    quickSort2(arr, pivotIndex + 1, right);
  }
}

// 分区函数 获取分区元素下标
function partition(arr, left, right) {
  let pivot = left, // 设定基准值（pivot）
    index = left;
  for (let i = pivot + 1; i <= right; i++) {
    if (arr[i] < arr[pivot]) {
      swap(arr, i, ++index);
    }
  }
  // 将pivot位置所在元素放到排序后应该在的位置
  swap(arr, pivot, index);
  // 返回pivot所在下标
  return index;
}

// 交换函数
function swap(arr, i, j) {
  let temp = arr[i];
  arr[i] = arr[j];
  arr[j] = temp;
}

let arr = Array(10)
  .fill(0)
  .map(() => parseInt(Math.random() * 100));
console.log([...arr]);
quickSort2(arr);
console.log(arr);
```

# 插入排序

![插入排序](assets/插入排序.gif)

**时间复杂度 O(n^2)**

将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。
从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。

```js
function insertionSort(arr) {
  for (let i = 1; i < arr.length; i++) {
    for (let j = i; j > 0; j--) {
      if (arr[j] >= arr[j - 1]) {
        break;
      }
      let temp = arr[j];
      arr[j] = arr[j - 1];
      arr[j - 1] = temp;
    }
  }
}

function insertionSort2(arr) {
  for (let i = 1; i < arr.length; i++) {
    let temp,
      curr = i;
    while (curr > 0 && arr[curr - 1] > arr[curr]) {
      temp = arr[curr - 1];
      arr[curr - 1] = arr[curr];
      arr[curr--] = temp;
    }
  }
}

var a1 = [7, 1, 44, 5, 55, 6, 33, 99, 123, 4, 77];
var a2 = [7, 1, 44, 5, 55, 6, 33, 99, 123, 4, 77];

insertionSort(a1);
insertionSort2(a2);

console.log(a1, a2);
```

# 选择排序

![选择排序](assets/选择排序.gif)

**时间复杂度 O(n^2)**

无论什么数据进去都是 O(n²) 的时间复杂度

首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。
再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。

```js
function selectionSort(arr) {
  for (let i = 0; i < arr.length; i++) {
    let minIndex = i,
      temp;
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[j] < arr[minIndex]) {
        minIndex = j;
      }
    }
    temp = arr[minIndex];
    arr[minIndex] = arr[i];
    arr[i] = temp;
  }
}

var a = [7, 1, 44, 5, 55, 6, 33, 99, 123, 4, 77];
console.log(a);
selectionSort(a);
console.log(a);
```

# 归并排序

![归并排序](assets/归并排序.gif)

**始终都是 O(nlogn) 的时间复杂度**

归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。

```js
function mergeSort(arr) {
  if (arr.length < 2) return arr; // 拆分到最底层就成了单个元素的数组
  // 1、先从上而下递归拆分arr为单个元素的数组
  const pivot = arr.length >> 1;
  const left = arr.slice(0, pivot);
  const right = arr.slice(pivot);

  // 2、再从下而上归并
  return merge(mergeSort(left), mergeSort(right));
}

// 归并函数

/**
 *
 * @param {*} left
 * @param {*} right
 *
 * 要理解这里的left和right一定是有序的，因为都是从两个单元素的数组归并而来，eg：merge([1], [2]) => [1, 2]
 */
function merge(left = [], right = []) {
  const ret = [];
  // 从小到大的往ret中放
  // 没有迭代完的部分一定比ret中的大，并且是有序的，并且left和right只有一个未迭代完
  while (left.length && right.length) {
    if (left[0] <= right[0]) {
      ret.push(left.shift());
    } else {
      ret.push(right.shift());
    }
  }

  while (left.length) {
    ret.push(left.shift());
  }

  while (right.length) {
    ret.push(right.shift());
  }

  return ret;
}

var a = [7, 1, 44, 5, 55, 6, 33, 99, 123, 4, 77];
console.log(a);
var ret = mergeSort(a);
console.log(ret);
```

# 基数排序

![LSD 基数排序](assets/LSD%20基数排序.gif)

**时间复杂度为O(d(n+radix))**，其中，一趟分配时间复杂度为O(n)，一趟收集时间复杂度为O(radix)，共进行d趟分配和收集。

```js
//LSD Radix Sort
var counter = [];
function radixSort(arr, maxDigit) {
  //maxDigit 最大数的位数
  var mod = 10;
  var dev = 1;
  // 按位上的数字 分桶排序  每个位分一次桶 排一次序 直到最高位排完
  for (var i = 0; i < maxDigit; i++, dev *= 10, mod *= 10) {
    // 按个、十、百、千、万...位上的数字分桶 0-9
    for (var j = 0; j < arr.length; j++) {
      var bucket = parseInt((arr[j] % mod) / dev);
      if (counter[bucket] == null) {
        counter[bucket] = [];
      }
      counter[bucket].push(arr[j]);
    }
    var pos = 0;
    for (var j = 0; j < counter.length; j++) {
      var value = null;
      if (counter[j] != null) {
        // 依次从1-9的桶里把数据放到arr中，1-9个桶之间本次迭代位上的数字是有序的
        while ((value = counter[j].shift()) != null) {
          arr[pos++] = value;
        }
      }
    }
  }
  return arr;
}
```
