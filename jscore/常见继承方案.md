# 原型对象

修改子类 prototype 为父类的一个实例

```js
function Parent() {
  this.props = [1, 2];
}
Sub.prototype = new Parent();

let sub = new Sub();
sub.props.push(3); //会影响所有Sub类实例继承自Parent的props
```

**无法独立继承父类构造函数中初始化的成员，通过 prototype 对象共享同一份成员**

# 构造函数式

.call 调用父类构造函数继承父类构造函数中初始化的成员，**无法继承 Parent.prototype 对象上的成员**

```js
function Parent() {
  this.props = [1, 2];
}

Parent.prototype.getName = function () {};

function Sub() {
  Parent.call(this);
  this.name = 'child';
}

let sub = new Sub();
sub.getName(); // sub.getName is not a function 无法继承Parent.prototype对象上的成员
```

# 组合式

原型对象结合.call 调用父类构造函数

**调用了两次父类构造函数、子类原型链上存在和自身相同的两份成员**

```js
function Parent() {
  this.props = [1, 2];
  this.name = 'Parent';
}

Parent.prototype.getName = function () {
  return this.name;
};

function Sub() {
  Parent.call(this);
  this.name = 'child';
}

Parent.prototype = new Parent();

let sub = new Sub();
sub.getName(); // child
```

# 原型式

基于 Object.create

**constructor 缺失，类型为父类，扩展繁琐**

```js
function Parent() {
  this.props = [1, 2];
  this.name = 'Parent';
}

let parent = new Parent();
let sub = Object.create(parent, { name: { value: 'child' } }); //扩展需要传第二个参数，并且返回的实例类型为Parent
```

# 寄生

工厂函数内调用 Object.create 创建新对象，并在工厂内给新对象扩展方法属性

**和原型式缺点相似**

```js
function Parent() {
  this.props = [1, 2];
  this.name = 'Parent';
}

function factory(parent) {
  const sub = Object.create(parent);
  sub.name = 'child';
  sub.getName = function () {
    return this.name;
  };
}

let parent = new Parent();
let sub = factory(parent);
sub.getName();
```

# 寄生组合

.call 调用父类构造函数+Object.create 创建扩展类的 prototype+修改扩展类 prototype 的 constructor + 给扩展类 prototype 添加方法

**基本是最优方案，和 babel 中的继承方案接近**

```js
function Parent() {
  this.props = [1, 2];
  this.name = 'Parent';
}

Parent.prototype.getName = function () {
  return this.name;
};

function Sub() {
  Parent.call(this);
  this.name = 'Sub';
}

// 通过Object.create继承prototype
function factory(ParentCtor, ChildCtor) {
  ChildCtor.prototype = Object.create(ParentCtor.prototype);
  ChildCtor.prototype.constructor = ChildCtor;
}

factory(Parent, Sub);

Sub.prototype.getProps = function () {
  return this.props;
};

let parent = new Parent();
let sub = new Sub();

console.log(sub.getProps(), sub.getName());
```


# typescript class extends 编译成es5时，编译出来的extends函数

```js
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

```